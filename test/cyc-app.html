<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>cyc-app</title>

    <script src="../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../bower_components/web-component-tester/browser.js"></script>

    <link rel="import" href="../dist/cyc-app/cyc-app.html">
  </head>
  <body>
    <test-fixture id="default">
      <template>
        <cyc-app></cyc-app>
      </template>
    </test-fixture>

    <script>
      suite('<cyc-app>', () => {
        let el;
        let $editorWindow;
        let $themeEditor;

        setup(() => {
          el = fixture('default');
          $editorWindow = el.$.editorWindow;
          $themeEditor = el.$.themeEditor;
        });

        test('fires an event "shell-loaded" on ready', () => {
          const spy = sinon.spy();
          el.addEventListener('shell-loaded', spy);
          el.ready(); // force ready
          assert.isTrue(spy.calledOnce);
        });

        suite('hover editor window', () => {
          test('displays the editor section hovered', () => {
            let hoveredSection;

            $editorWindow.addEventListener('editor-section-hover', (event) => {
              hoveredSection = event.detail;
            });

            $editorWindow.dispatchEvent(new CustomEvent('editor-section-hover', {
              detail: 'any',
            }));

            const $sectionInfo = el.shadowRoot.querySelector('.hover-info');
            assert.equal($sectionInfo.innerText, hoveredSection);
          });

          test('hover info is empty (hidden) when the editor window is not hovered after 100ms', () => {
            const $sectionInfo = el.shadowRoot.querySelector('.hover-info');
            const timeoutStub = sinon.stub(window, 'setTimeout', function(cb) {
              cb.call(el);
            });

            $editorWindow.dispatchEvent(new CustomEvent('editor-section-hover', {
              detail: 'any',
            }));

            $editorWindow.dispatchEvent(new MouseEvent('mouseleave'));
            assert.equal($sectionInfo.innerText, '');
            timeoutStub.restore();
          });
        });

        suite('clicking an editor section', () => {
          setup(() => {
            $editorWindow.dataset.prop = 'activityBar.background';
            $themeEditor.colors = [{prop: 'activityBar.background', value: '#141820', cssVar: '--activityBar-background'}];
          });

          test('clicking an editor section in the editor window sets editProperty in theme-editor', () => {
            $editorWindow.dispatchEvent(new Event('click'));
            assert.equal($themeEditor.editProperty, 'activityBar.background');
          });

          test('clicking an editor section calls openColorPicker() method of theme-editor', () => {
            const openColorPickerStub = sinon.stub($themeEditor, 'openColorPicker');
            $editorWindow.dispatchEvent(new Event('click'));
            assert.isTrue(openColorPickerStub.called);
          });
        });

        suite('theme data', () => {
          let $dm;

          const mockPayloadDM = {
            name: 'some theme',
            type: 'dark',
            colors: [{
              prop: 'activitybar.background',
              value: '#000000',
              cssVar: '--activityBar-background',
            }],
          };

          setup(() => {
            $dm = el.$.dmTheme;

            $dm.dispatchEvent(new CustomEvent('response-success', {
              detail: mockPayloadDM,
            }));
          });

          test('sets colors in theme-editor when the DM fires "response-success"', () => {
            assert.deepEqual($themeEditor.colors, mockPayloadDM.colors);
          });

          test('sets theme-name in editor-window when the DM fires "response-success"', () => {
            assert.equal($editorWindow.themeName, mockPayloadDM.name);
          });
        });
      });
    </script>
  </body>
</html>
